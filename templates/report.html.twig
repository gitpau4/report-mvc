{% extends "base.html.twig" %}

{% block title %}Report{% endblock %}

{% block body %}
    <h1>Redovisning</h1>

    <article>
        <section id="kmom01">
        <h2>Kmom01</h2>
        <p>
            Tidigare har jag jobbat med objektorientering i dbwebb kursen oopython, och även en kurs i objektorienterad Java. 
            PHPs modell för klasser och objekt bygger på objektorienterad programmering. 
            Den objektorienterade modellen skapar en tydlig struktur och gör det lätt att få till DRY kod. 
            Man skapar klasser som är som en mall för objekt. 
            Ett objekt är en instans av en klass, och den kan ha medlemsvariabler (properties) och metoder. 
            Metoder visar allt som objektet kan göra, till exempel ändra läge för objektet eller utföra en uppgift.
        </p>
        <p>
            Jag uppfattar kodbasen till uppgiften som ganska stor med väldigt många filer, men väl strukturerade. 
            Det finns en tydlig uppdelning mellan routes, templates, bilder och styling till exempel. 
            Koden i sig känner man igen då vi jobbat med php, html och twig innan i tidigare kurser.
        </p>
        <p>
            I artikeln "PHP the right way" tycker jag att delen om säkerhet känns intressant och viktig. 
            Där skrivs det bland annat om "password hashing", vilket betyder att transformera lösenord till strängar med en hash funktion, som sedan inte går att transformera tillbaks till orginalet. 
            Detta skiljer sig från "encrypting" där man kan transformera tillbaks strängen med hjälp av en nyckel, och därför är just hashing det man ska använda för lösenord. 
            Det skrivs även om "data filtering" som innebär att man ska sanera och validera all input som kommer in utifrån, då man aldrig ska lita på sådan. 
            I en annan del av artikeln skrivs det om testing, bland annat unit testing, vilket är bra att kunna. 
            Det jobbade vi med i kursen oopython, och jag märkte då hur använbart det var, att enkelt kunna se om delar av koden fungerar som den ska.
        </p>
        <p>
            Mitt TIL för detta kmom är att göra en egen readme fil.
        </p>
        </section>

        <section id="kmom02">
            <h2>Kmom02</h2>
            <p>
                Arv används i php när en klass ärver attribut och metoder från en annan klass. 
                Den ärvande klassen kallas subklass och basklassen kallas superklass. 
                Man kan säga att subklassen utökar superklassen. 
                Komposition innebär att en klass refererar till en annan i sina attribut. 
                Man brukar kalla det för en <i>has-a</i> relation, alltså att <i>klass 1 har en klass2</i>. 
                Interface innebär att man specifierar vilka metoder en klass <b>ska</b> att implementera. 
                Trait liknar arv, alltså den innehåller attribut och metoder som andra klasser använder. 
                Skillnaden från arv är att klassen kan använda flera olika traits.
            </p>
            <p>
                Jag började med att skapa klasserna med metoder som jag tänkte skulle behövas. 
                Under arbetets gång fick jag justera klasserna så att de kunde lösa all funktionalitet som behövdes för uppgiften. 
                Jag skapade två olika controller klasser, en för twig och en för json. 
                Vissa twig templates använde jag till flera routes, tex deck och shuffle använder samma twig template, vilket gör koden lite mer dry. 
                Ett förbättringspotential jag ser är att jag just nu har en metod för att hämta data från sessionen som är likadan i båda controllers, 
                där skulle jag kanske kunna skapa en klass med metoden som de båda kan hämta metoden från. 
                Jag skulle även kunna göra knappen på api landningssidan för att dra flera kort mer flexibel, just nu är knappen hårdkodad på 5 st kort.
            </p>
            <p>
                Mina reflektioner över att jobba i Symfony är att det är ganska likt hur vi jobbade i oopython kursen. 
                I alla fall yahtzee i oopython och nu med kortleken, strukturen på filerna med templates och routes är ganska lik. 
                Det är en struktur jag börjat gilla, för det ger en uppdelning mellan logiken och presentationen.
            </p>
            <p>
                Mitt TIL för detta kmom är att man kan spara hela objekt i sessionen i php.
            </p>
            <p>
                Referenser:
                <ul>
                    <li><a href="https://www.w3schools.com/php/php_oop_what_is.asp">w3schools PHP - What is OOP?</a></li>
                    <li><a href="https://dbwebb.se/guide/kom-igang-med-objektorienterad-programmering-i-php">dbwebb Kom igång med Objektorienterad programmering i PHP</a></li>
                </ul>
            </p>
        </section>

        <section id="kmom03">
            <h2>Kmom03</h2>
            <p>
                Jag tyckte att det hjälpte mig att börja programmera när jag redan hade ett flödesdiagram och pseudokod. 
                Vanligtvis brukar jag börja koda ganska direkt och inte ha en väldigt genomtänkt plan. 
                För större projekt är det definitivt en fördel att ha en plan innan man börjar koda, för att få så bra kod och struktur som möjligt. 
                Jag tror även att det kan spara en del tid. 
                Innan jag började projektet trodde jag att jag skulle lägga ganska lite tid på förberedelsen med flödesdiagram och pseudokod, och mycket tid på själva kodandet. 
                Men det visade sig inte bli som jag tänkte, jag la mycket mer tid på förberedelsen än jag trodde, sen blev inte slutresultatet exakt enligt förberedelsen, men ganska likt. 
                Att komma igång med kodandet kändes lätt eftersom jag redan visste till stor del vad som skulle göras, så det kändes inte lika överväldigande att komma igång. 
            </p>
            <p>
                För att lösa uppgiften skapade jag två ytterligare klasser, Player och GameLogic, och använde de klasser som redan fanns från kmom02. 
                GameLogic har övergripande koll på spelets logik, och innehåller både spelare och kortlek. 
                Player klassen representerar en spelare eller bank, och den har inte direkt någon egen metod förutom två getters och en metod som hämtar från CardHand. 
                Därför var jag lite osäker på om den klassen var nödvändig eller om det räckte med bara CardHand. 
                Men jag tror ändå det var bra att jag behöll Player klassen, för det gör koden i GameLogic tydligare, och kan vara bra att ha om man utökar spelet. 
                Jag är ganska nöjd med resultatet, men spelet hade kunnat förbättras genom att göra några av de valfria kraven, om jag hade haft tid över. 
                Jag tycker jag fick till en ganska 'smal' controller fil med lite kod, men man hade kanske kunnat få till ännu mindre kod och ha fler metoder i klasserna. 
            </p>
            <p>
                Min känsla för att koda med ramverket Symfony är jag lär mig att uppskatta strukturen mellan logik och presentation med templates. 
                Jag tycker att Symfony gör det lite lättare att jobba med sessionen, då det finns bra inbyggda funktioner till sessionen. 
            </p>
            <p>
                Mitt TIL för detta kmom är hur man gör flödesdiagram.
            </p>
        </section>

        <section id="kmom04">
            <h2>Kmom04</h2>
            <p>
                Jag upplever att det är bra att testa sin kod genom att skriva testfall med phpunit, då det är i slutändan smidigare än att försöka testa koden på andra sätt. 
                Det tar självklart tid att skriva all testkod, men det gör testningen smidigare när man är klar. 
                Vissa metoder och klasser kändes enkla att testa och andra mer krävande. 
                Ibland var det svårt att veta om testfallet var bra och användbart, men kodtecknings dokummentationen hjälpte en att skriva täckande testfall. 
                Jag nådde 100% kodtäckning på samtliga klasser. 
            </p>
            <p>
                Jag upplever min kod som ganska testbar. 
                Jag har ganska många små metoder med konkreta ansvarsområden vilket gör det lättare att testa, än om jag hade haft få stora metoder. 
            </p>
            <p>
                Jag lade till en metod i GameLogic klassen för att göra koden mer testbar. 
                Jag behövde nämligen komma åt 'deck' för att kunna testa shuffle-metoden, så det var bara att lägga till en getDeck metod. 
                Annars ändrade jag inget i koden. 
            </p>
            <p>
                Jag tror absolut att en testbar kod och 'snygg och ren' kod hänger ihop. 
                Jag tänker att en testbar kod är sammanhängande och har bra strukturerad, för att vara enkel att testa. 
                Även att metoderna är lagom uppdelade, alltså inte allt för stora metoder som gör väldigt mycket, utan det är lättare att testa flera mindre metoder. 
                Det gör också koden mer läsbar och enkel att förstå, vilket jag tycker blir 'snyggt och rent'. 
                Jag skulle alltså säga att testning inte bara är bra för att hitta fel utan också för att göra sin kod bättre och snyggare. 
            </p>
            <p>
                Mitt TIL för detta kmom är hur man skriver enhetstester i phpunit, och att det finns lite olika asserts som till exempel assertCount för att verifiera antalet element i en array.
            </p>
        </section>

        <section id="kmom05">
            <h2>Kmom05</h2>
            <p>
                Övningen med Doctrine gick bra. 
                Jag stötte inte på några större problem under själva övningen direkt, 
                men när jag skapade en ny databas till biblioteket så fick jag varningsmeddelande om att jag hade migrations från en tidigare databas kvar. 
                Jag tog då bort de gamla migrationsfilerna och körde migrate igen, då gick det bra. 
                Under övningen tänkte jag på att det var smidigt att skapa entiteter till databasen. 
            </p>
            <p>
                Jag klurade ett tag på hur jag skulle bygga upp bibliotekets användargränssnitt. 
                Jag ville ha det enkelt. 
                Till en början tänkte jag ha en framsida med länkar till alla grejer man kan göra (skapa, visa, uppdatera, ta bort). 
                Men jag insåg att det var lättare att bara ha 'skapa' och 'visa alla böcker' på framsidan, 
                och sedan inuti visa-sidan kunna gå vidare till saker som har med specifika böcker att göra, till exempel uppdatera en viss bok. 
                Jag la även till bakåt-knappar för att lättare kunna navigera runt. 
            </p>
            <p>
                Att jobba med CRUD i ORM gick bra. 
                Till skillnad från andra sätt så skriver man här ingen egen SQL kod, om man inte vill. 
                Det är dock bra att man kan skriva egen SQL om man vill, jag vet inte riktigt vad jag föredrar än. 
                Man kan få till kompaktare kod när man inte skriver massor av SQL kod, vilket är positivt. 
                Det negativa med mycket automatgenererat är att man inte lär sig databas logiken själv riktigt. 
            </p>
            <p>
                Att jobba med ORM känns relativt smidigt. 
                Däremot känns det som att man har mindre 'insyn' i vad som händer i databasen jämfört med andra sätt att jobba mot databaser. 
                Jag tror absolut att ORM är smidigare för stora projekt med mycket data. 
                Det är ganska skönt att slippa skriva upprepande SQL kod, det gör att man sparar tid. 
                Det är även lättare att få till strukturerad kod. 
            </p>
            <p>
                Mitt TIL för detta kmom är att man kan skapa automatgenererade formulär kopplat till entiteter, med hjälp av Symfony. 
            </p>
        </section>

        <section id="kmom06">
            <h2>Kmom06</h2>
            <p>
                Jag uppskattar överblicken man får, med bilden på cirklarna som representerar Maintainabiliy Index samt Cyclomatic Complexity. 
                Det ger en bra visuell bild över kodens kvalitet. 
                Jag uppskattar även att man tydligt kan se alla klassers mätvärden i tabeller, och även sortera efter ett visst värde. 
                Däremot hade jag önskat lite mer info om vad mätvärdena innebär, typ någon liten inforuta som man kan klicka på för att veta vilket spann anses bra eller dåligt. 
            </p>
            <p>
                Det gick bra att integrera Scrutinizer med mitt git repo, jag stötte inte på några problem. 
                Badges och cirkeldiagrammet ger en tydlig sammanfattning på koden värden. 
                Jag uppskattar att verktyget visar vilka issues man har och skriver exakt var och varför dessa issues finns. 
                Jag gillar även att man kan se betyget på varje metod, då kan man enkelt och snabbt se vilken metod som kanske bör åtgärdas. 
                Jag fick kodtäckning 18% och kodkvalitet 9.96 efter första bygget. 
            </p>
            <p>
                Min egna syn på kodkvalitet och dessa verktyg är att de kan ge en väldigt bra fingervisning på om ens kod har bra kvalitet eller inte. 
                Däremot inte helt och hållet, ibland tror jag att man behöver fundera på om koden verkligen alltid blir bättre av att jaga utmärkta mätvärden. 
                I vissa fall kanske koden blir mer praktiskt, logisk eller lättare att förstå om man struntar i att följa en del av vertygens rekommendationer. 
                Ett exempel är else satsen, som man gärna ska undvika. Men det finns fall där jag tycker den gör koden betydligt mer lättläst och mer logisk. 
                Jag tror man ska använda verktygen som ett hjälpmedel, men inte som en lag. 
                Då kan man uppnå kvalitativ kod utan att spendera många timmar på att rätta saker som kanske egentligen inte är fel. 
            </p>
            <p>
                Mitt TIL för detta kmom är att det finns många fler mätningar man kan göra på kod, än vad jag hade trott innan. 
                Till exempel att man kan sätta en siffra på hur komplex koden är, eller hur lätt den är att underhålla (Maintainabiliy index).
            </p>
        </section>

        <section id="kmom10">
            <h2>Kmom10 Projekt</h2>
            <h3>Krav 1-3</h3>
                <p>
                    Jag valde projektet äventyrsspel, då jag tyckte det lät som det roligaste projektet. 
                    Först tänkte jag ut vilka rum som jag ville ha, och vad man ska göra i spelet. 
                    Därefter började jag att fundera över vilka klasser som var lämliga att ha med, tillslut bestämde jag mig för Room, Item, Player och AdventureLogic. 
                    Player-klassen innehåller egentligen bara ett inventory, men jag valde att ha en Player-klass så man enkelt kan lägga till fler egenskaper till en spelare ifall man vill utöka spelet. 
                    Sedan implementerade jag dessa klasser och skapade metoder jag tänkte jag skulle behöva. 
                    Sedan skapade jag en controller och twig templates, och justerade koden i klasserna när jag insåg att det behövdes.
                    Härnäst fixade jag stylingen till spelet, jag ville ha en retro (typ 80-tal ui) medeltida känsla, detta uppnås med typsnitten, färgpaletten och stilen på knapparna. 
                    Jag skapade även testklasser som testar klassernas metoder, jag uppnådde en kodtäckning på 98.88% för src/Adventure-mappen. 
                    När jag skapade testklassen för AdventureLogic insåg jag att interact-metoden var väldigt hårdkodad för just de interaktioner som går att göra i spelet just nu. 
                    Därmed var den lite svårtestad, då jag skapat en egen testdata-jsonfil. 
                    Därför ändrade jag om den metoden så att den blev mer generell, så man skulle kunna lägga till fler actions utan att behöva ändra om och lägga till i koden. 
                </p>
            <h3>Krav 4</h3>
                <p>
                    Jag skapade först en landingssida för projektets API, där samlades länkar och knappar för att testa API:t. 
                    Sedan skapade jag en separat controller för json routsen. 
                    Jag bestämde mig för att skapa dessa routes: info om alla rum, info om specifikt rum, spelarens inventarium, flytta i riktning, plocka föremål, interagera med objekt. 
                    De tre sistnämnda är post-routes. 
                </p>
            <h3>Genomförande</h3>
                <p>
                    Projektet var väldigt kul och lärorikt att göra. 
                    Vissa delar var svåra, vissa var lätta. 
                    Efter projektet tycker jag att jag fått en bättre förståelse för objektorientering, klasser och struktur. 
                    Det svåraste var nog att göra interact-metoden generell, att göra en metod som funkar för olika typer av interaktioner i spelet. 
                    Även att initiera rummen i AdventureLogic klassen var lite klurigt. 
                    De andra klasserna var relativt enkla att implementera. 
                    Styligen tar alltid lite längre tid än tänkt, men denna gång tycker jag att det gick ganska smidigt att få till en styling jag var nöjd med. 
                    Det tog dock lite tid att lägga move-knapparna i de positioner jag ville. 
                    Generellt var det ett bra projekt för kursen!
                </p>
            <h3>Tankar om kursen</h3>
                <p>
                    Jag är nöjd med kursen. 
                    Vissa kursmoment var kluriga och tog lång tid, men då är de också lärorika. 
                    Jag tycker att kursmaterialet är bra och tydligt. 
                    Jag har lärt mig en hel del och vissa uppgifter var extra roliga att lösa, till exempel kortspel och slutprojektet. 
                    Kursen får 8/10.
                </p>
        </section>
    </article>
{% endblock %}